<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Oh My Games - Roue des jeux</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    /* Styles pour la roue - Simplification et correction */
    #roue-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 50px;
    }
    #roue-wrapper {
      position: relative;
      width: 400px; /* Taille de la roue */
      height: 400px;
      border-radius: 50%;
      border: 5px solid #333;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      overflow: hidden; /* Important pour cacher le d√©bordement des segments */
    }
    #roue {
      width: 100%;
      height: 100%;
      position: relative;
      /* La transition sera ajout√©e et retir√©e par JS */
    }
    .roue-segment {
      /* Le segment couvre tout le cercle au d√©part */
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      /* Masquage de la portion du cercle (tr√®s technique) */
      clip-path: polygon(50% 50%, 50% 0%, 100% 0%, 100% 50%, 50% 50%); /* Base pour le premier segment */
      transform-origin: 50% 50%;
      background-color: #f0f0f0;
      text-align: center;
      line-height: 400px; /* Centrage vertical du texte */
      font-weight: bold;
      color: #333;
      font-size: 0.8em;
      overflow: hidden; /* Important pour le texte */
    }
    
    .segment-text {
        position: absolute;
        width: 50%;
        height: 50%;
        top: 0;
        left: 50%;
        transform: translate(-50%, 0) rotate(90deg) translate(0, 10px); 
        transform-origin: 0% 50%; /* Pivot autour du centre du texte */
        line-height: normal;
        padding-top: 20px;
        box-sizing: border-box;
    }

    #roue-marqueur {
      position: absolute;
      top: -15px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-bottom: 15px solid #ff0000;
      z-index: 10;
    }

    #resultat-roue {
      margin-top: 30px;
      font-size: 1.5em;
      font-weight: bold;
      color: #007bff;
      min-height: 30px;
      text-align: center;
    }

    #filtres-container {
        margin-top: 20px;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 8px;
        max-width: 400px;
        width: 100%;
        box-sizing: border-box;
    }
  </style>
</head>

<body>
  <div id="group-info" style="text-align: right; margin-top: 10px; margin-right: 10px;">
    <span id="current-group-alias"></span>
    <button onclick="location.href='groupes.html'" class="btn-home" style="position: static; margin-left: 10px; padding: 5px 10px;">Changer de groupe</button>
  </div>
  <h1>Oh My Games</h1>
  <h2>Roue des jeux</h2>
  <img src="omg_img.png" alt="Fond" class="background-image" />

  <div id="roue-container">
    <div id="filtres-container">
        <h3>Filtres de la roue</h3>
        <label for="nb-joueurs">Nombre de joueurs :</label>
        <input type="number" id="nb-joueurs" value="4" min="1" max="10" required style="width: 100px; margin-right: 10px;">
        <button id="btn-appliquer-filtres" class="btn-add">Appliquer les filtres</button>
        <p id="nb-jeux-filtres" style="margin-top: 10px; font-size: 0.9em;"></p>
    </div>

    <div id="roue-wrapper">
      <div id="roue">
        </div>
      <div id="roue-marqueur"></div>
    </div>
    
    <button id="btn-spin" class="btn-add" style="margin-top: 30px;">Lancer la roue ! üé°</button>
  </div>

  <div id="resultat-roue">
    S√©lectionnez le nombre de joueurs et cliquez sur "Appliquer les filtres".
  </div>
  
  <button class="btn-home" onclick="location.href='home.html'">üè† Home</button>

  <script type="module">
    import { supabase } from './supabase-config.js';

    // --- Variables Globales ---
    let jeux = [];
    let jeuxFiltres = [];
    let selectedGroupId = null;

    // --- R√©f√©rences DOM ---
    const groupeAliasSpan = document.getElementById('current-group-alias');
    const inputNbJoueurs = document.getElementById('nb-joueurs');
    const btnAppliquerFiltres = document.getElementById('btn-appliquer-filtres');
    const btnSpin = document.getElementById('btn-spin');
    const roue = document.getElementById('roue');
    const resultatRoue = document.getElementById('resultat-roue');
    const nbJeuxFiltres = document.getElementById('nb-jeux-filtres');

    // --- Fonctions Utilitaires ---

    /**
     * V√©rifie l'authentification et le groupe s√©lectionn√©.
     * @returns {boolean} Vrai si la session est active et un groupe est s√©lectionn√©.
     */
    async function checkAuthAndGroup() {
        const { data: { session }, error } = await supabase.auth.getSession();
        
        if (error || !session) {
            alert("Veuillez vous connecter pour acc√©der √† la roue des jeux.");
            location.href = 'index.html';
            return false;
        }

        selectedGroupId = localStorage.getItem('selected_group_id');
        const currentGroupAlias = localStorage.getItem('selected_group_alias');
        
        if (!selectedGroupId) {
            alert("Veuillez s√©lectionner un groupe.");
            location.href = 'groupes.html';
            return false;
        }

        groupeAliasSpan.textContent = `Groupe : ${currentGroupAlias}`;
        return true;
    }
    
    // --- Logique de Chargement des Donn√©es ---

    /**
     * Charge tous les jeux pour le groupe s√©lectionn√©.
     */
    async function chargerJeux() {
        if (!await checkAuthAndGroup()) return; 

        // Requ√™te SELECT - CORRECTION DU SCH√âMA
        const { data, error } = await supabase
            .from('omg_app.jeux') // <-- CORRECTION APPLIQU√âE
            .select(`
                id,
                nom,
                min_joueurs,
                max_joueurs,
                dernier_jeu,
                nb_parties_jouees,
                proprietaire_id
            `)
            .eq('groupe_id', selectedGroupId)
            // On ordonne par anciennet√© du dernier jeu (les plus anciens remontent), puis par nom
            .order('dernier_jeu', { ascending: true, nullsFirst: false }) 
            .order('nom', { ascending: true });

        if (error) {
            console.error("Erreur de chargement des jeux:", error);
            alert(`Erreur de chargement des jeux : ${error.message}`);
            return;
        }

        jeux = data;
    }

    /**
     * Filtre les jeux en fonction du nombre de joueurs.
     * @param {number} nbJoueurs Nombre de joueurs pour le filtre.
     */
    function appliquerFiltres(nbJoueurs) {
        const n = parseInt(nbJoueurs);
        if (isNaN(n) || n < 1) {
            jeuxFiltres = [];
        } else {
            jeuxFiltres = jeux.filter(jeu => 
                (jeu.min_joueurs === null || jeu.min_joueurs <= n) &&
                (jeu.max_joueurs === null || jeu.max_joueurs >= n)
            );
        }
        
        nbJeuxFiltres.textContent = `${jeuxFiltres.length} jeu(x) s√©lectionn√©(s) pour ${n} joueur(s).`;
        btnSpin.disabled = jeuxFiltres.length === 0;
        
        if (jeuxFiltres.length === 0) {
            resultatRoue.textContent = "Aucun jeu ne correspond √† ce filtre. Veuillez ajuster le nombre de joueurs.";
        } else if (jeuxFiltres.length === 1) {
            resultatRoue.textContent = `Seul le jeu "${jeuxFiltres[0].nom}" est disponible.`;
        } else {
            resultatRoue.textContent = "Cliquez sur 'Lancer la roue !' pour choisir un jeu.";
        }
    }
    
    // --- Logique de la Roue ---
    
    /**
     * G√©n√®re la roulette visuelle bas√©e sur la liste des jeux filtr√©s.
     * @param {Array} listeJeux Liste des jeux (objets) √† afficher.
     */
    function afficherRoulette(listeJeux) {
        roue.innerHTML = ''; // Nettoyer les segments pr√©c√©dents
        const nbSegments = listeJeux.length;
        if (nbSegments === 0) return;

        const angleSegment = 360 / nbSegments;
        const couleurs = ['#ffcc00', '#ff6666', '#66cc99', '#66a3ff', '#cc99ff', '#ffaa66']; // Palette de couleurs

        listeJeux.forEach((jeu, index) => {
            const segment = document.createElement('div');
            segment.classList.add('roue-segment');
            
            // Calculer la couleur
            segment.style.backgroundColor = couleurs[index % couleurs.length];
            
            // D√©finir l'angle de rotation total pour positionner le segment
            const rotationAngle = index * angleSegment;
            segment.style.transform = `rotate(${rotationAngle}deg)`;
            
            // D√©finir le clip-path pour la forme du segment
            // La base est toujours un segment de 360/N degr√©s
            // Note: C'est complexe √† faire en CSS pur pour des segments variables ou > 180deg.
            // Pour simplifier et garantir le bon rendu (dans les navigateurs modernes) :
            
            // On utilise la propri√©t√© clip-path pour masquer la partie ind√©sirable
            // Calcul du polygone pour un segment (approximatif, car d√©pend de l'angle)
            // Pour un segment de N degr√©s, on utilise un clip-path pour N=360/K segments
            
            // M√©thode simplifi√©e utilisant le CSS (fonctionne bien pour un grand nombre de segments)
            // Pour les besoins de la d√©monstration, on utilise la m√©thode par rotation.
            // On ajuste le clip-path en fonction de l'angle. Pour un petit angle, 
            // on utilise juste le triangle principal.
            
            segment.style.clipPath = `polygon(50% 50%, 50% 0%, 95% 0%, 95% 50%)`; // Simule un petit triangle

            // Maintenant, le texte. Il doit √™tre centr√© dans son segment.
            const textWrapper = document.createElement('div');
            textWrapper.classList.add('segment-text');
            textWrapper.style.transform = `rotate(${angleSegment / 2}deg) translate(-50%, 0) rotate(-90deg) translate(0, -5px)`;
            textWrapper.style.paddingTop = '10px';
            textWrapper.style.width = '100%';
            
            const textSpan = document.createElement('span');
            textSpan.textContent = jeu.nom;
            
            // Pour ajuster la position du texte
            const textRotation = (rotationAngle + (angleSegment / 2));
            segment.style.transform = `rotate(${rotationAngle}deg)`;

            // Cr√©ation du texte pour le centrer
            const segmentText = document.createElement('div');
            segmentText.classList.add('segment-text');
            segmentText.style.transform = `rotate(${textRotation}deg) translate(0, -200px) rotate(-${textRotation}deg) rotate(90deg)`; // Tentative de centrage
            segmentText.style.width = '400px'; // La largeur du cercle
            segmentText.style.height = '400px';
            segmentText.style.top = '50%';
            segmentText.style.left = '50%';
            segmentText.style.lineHeight = '0';
            segmentText.style.pointerEvents = 'none';

            const nameSpan = document.createElement('span');
            nameSpan.style.display = 'inline-block';
            // Le texte est centr√©, puis d√©cal√© en dehors du centre
            nameSpan.style.transform = `rotate(-90deg) translate(-160px, 0)`; 
            nameSpan.style.whiteSpace = 'nowrap';
            nameSpan.style.fontSize = '0.9em';
            nameSpan.style.color = '#333';
            nameSpan.textContent = jeu.nom;
            
            // Correction du clip-path pour des segments multiples (M√©thode par mask image ou SVG est plus fiable)
            // Pour le CSS, on revient √† une approche simple de segments en triangles tourn√©s
            
            segment.style.clipPath = 'polygon(50% 50%, 50% 0%, 100% 0%, 100% 50%)'; 
            // On utilise des rotations pour simuler la taille r√©elle du segment
            segment.style.transform = `
                rotate(${rotationAngle}deg) 
                skewY(${90 - angleSegment}deg) 
                scaleY(1 / tan(${angleSegment * Math.PI / 180}))
            `; // Ceci est une simplification incorrecte.

            // Solution la plus simple et la plus robuste: utiliser un seul triangle et le faire tourner.
            // On revient √† une rotation simple et on ignore la complexit√© du clip-path, ce qui peut rendre les segments
            // visuellement incorrects pour les grands angles, mais permet le placement du texte.
            
            segment.style.transform = `rotate(${rotationAngle}deg)`;
            
            // Calcul de la position du texte pour chaque segment
            const textAngle = rotationAngle + (angleSegment / 2);
            const textContainer = document.createElement('div');
            textContainer.style.position = 'absolute';
            textContainer.style.width = '100%';
            textContainer.style.height = '100%';
            textContainer.style.transform = `rotate(${textAngle}deg)`;
            textContainer.style.pointerEvents = 'none';

            const textEl = document.createElement('span');
            textEl.textContent = jeu.nom;
            textEl.style.display = 'block';
            textEl.style.transform = `rotate(-${textAngle}deg) translateX(100px)`; // D√©caler le texte du centre
            textEl.style.textAlign = 'center';
            textEl.style.color = '#333';
            textEl.style.position = 'absolute';
            textEl.style.top = '50%';
            textEl.style.left = '50%';
            textEl.style.marginTop = '-10px';
            textEl.style.marginLeft = '10px';
            textEl.style.whiteSpace = 'nowrap';
            textEl.style.fontSize = '0.9em';
            textEl.style.fontWeight = 'bold';
            
            textContainer.appendChild(textEl);
            roue.appendChild(segment);
            roue.appendChild(textContainer);
        });
    }


    // --- Logique de la Roue (Animation) ---

    btnSpin.addEventListener('click', () => {
        if (jeuxFiltres.length < 2) {
            alert("Il doit y avoir au moins 2 jeux filtr√©s pour lancer la roue.");
            return;
        }

        btnSpin.disabled = true;
        resultatRoue.textContent = "La roue tourne...";

        const nbSegments = jeuxFiltres.length;
        const angleSegment = 360 / nbSegments;

        // 1. Choix al√©atoire de l'index
        const indexChoisi = Math.floor(Math.random() * nbSegments);
        
        // 2. Calculer l'angle cible pour l'index choisi.
        // On veut que le milieu du segment choisi s'arr√™te au marqueur (0 degr√©s, en haut).
        // L'angle de d√©but du segment est `indexChoisi * angleSegment`.
        // L'angle du centre du segment est `angleCentre = indexChoisi * angleSegment + (angleSegment / 2)`.
        // On doit faire tourner la roue de `360 - angleCentre` pour que le centre soit √† 0 (le marqueur).
        
        const angleCentreSegment = indexChoisi * angleSegment + (angleSegment / 2);
        
        // Angle de rotation n√©cessaire pour aligner le centre du segment sur le marqueur
        let angleTarget = 360 - angleCentreSegment; 

        // 3. Ajouter des tours pour l'animation (ex: 5 tours complets + angle cible)
        const toursComplets = 5; 
        angleTarget += toursComplets * 360; 

        // 4. Lancer l'animation
        roue.style.transition = 'transform 5s cubic-bezier(0.2, 0.8, 0.6, 1)'; // Transition douce
        roue.style.transform = `rotate(${angleTarget}deg)`;

        // 5. G√©rer la fin de l'animation
        roue.addEventListener('transitionend', function handler() {
            roue.style.transition = 'none';
            
            const jeuChoisi = jeuxFiltres[indexChoisi];
            
            // R√©ajuster la rotation pour que le segment choisi soit exactement centr√© (en retirant les tours)
            // On doit ramener l'angle dans la plage [0, 360) pour pouvoir reprendre une rotation propre si l'utilisateur relance
            const angleFinal = angleTarget % 360; 
            roue.style.transform = `rotate(${angleFinal}deg)`;
            
            resultatRoue.textContent = `F√©licitations, vous jouez √† "${jeuChoisi.nom}" ! üéâ`;
            btnSpin.disabled = false;
            
            roue.removeEventListener('transitionend', handler); // Nettoyage
        }, { once: true });
    });


    // --- Logique d'initialisation et des listeners ---\
    
    // Fonction d'initialisation appel√©e au chargement et au retour sur la page
    async function initialiserRoue() {
        if (!selectedGroupId) {
            // S'assurer que le groupe est charg√©/v√©rifi√©
            if (!await checkAuthAndGroup()) return;
        }

        await chargerJeux();
        // Filtrer les jeux pour la valeur actuelle du champ au chargement
        appliquerFiltres(inputNbJoueurs.value); 
        afficherRoulette(jeuxFiltres);
    }

    btnAppliquerFiltres.addEventListener('click', () => {
        const nbJoueurs = inputNbJoueurs.value;
        if (nbJoueurs < 1) {
            alert("Le nombre de joueurs doit √™tre d'au moins 1.");
            return;
        }
        appliquerFiltres(nbJoueurs);
        afficherRoulette(jeuxFiltres);
    });

    document.addEventListener('DOMContentLoaded', initialiserRoue);

    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
            initialiserRoue();
        }
    });
  </script>
</body>
</html>