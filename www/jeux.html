<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Oh My Games - Jeux</title>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <div id="group-info" style="text-align: right; margin-top: 10px; margin-right: 10px;">
    <span id="current-group-alias"></span>
    <button onclick="location.href='login.html'" style="margin-left: 10px;">Changer de groupe</button>
  </div>
  <h1>Oh My Games</h1>
  <h2>Liste des jeux</h2>
  <img src="omg_img.png" alt="Fond" class="background-image" />

  <button class="btn-add">➕ Ajouter un jeu</button>

  <div id="alpha-filter-container">
  </div>

  <input type="text" id="recherche-jeux" placeholder="🔍 Rechercher un jeu..." />

  <div id="liste-jeux">
  </div>

  <div id="modal-ajout" class="modal">
    <div id="modal-content" class="modal-content">
      <button id="btn-fermer" class="close-button">&times;</button>
      <h3>Ajouter/Modifier un jeu</h3>
      <form id="form-ajout">
        <input type="hidden" id="jeu-id">
        <label for="nom-jeu">Nom du jeu :</label>
        <input type="text" id="nom-jeu" name="nom-jeu" required><br><br>

        <label for="proprietaire-jeu">Propriétaire :</label>
        <select id="proprietaire-jeu" name="proprietaire-jeu">
          <option value="">Sélectionner un propriétaire</option>
          <option value="ajouter-proprietaire">➕ Ajouter un propriétaire</option>
        </select><br><br>

        <label for="photos-jeu">Photos du jeu (optionnel) :</label>
        <input type="file" id="photos-jeu" name="photos-jeu" accept="image/*" multiple><br><br>

        <div id="photos-preview-container" style="display: none; margin-bottom: 10px;">
            <p>Photos actuelles :</p>
            <div id="photos-preview" style="display: flex; gap: 10px; flex-wrap: wrap;"></div>
        </div>

        <label for="min-joueurs">Min. Joueurs :</label>
        <input type="number" id="min-joueurs" name="min-joueurs" min="1" value="1"><br><br>

        <label for="max-joueurs">Max. Joueurs :</label>
        <input type="number" id="max-joueurs" name="max-joueurs" min="1" value="4"><br><br>

        <input type="checkbox" id="prete" name="prete">
        <label for="prete">Prêté à quelqu'un</label><br>
        <input type="text" id="prete-a" name="prete-a" placeholder="Nom de la personne" style="display: none;"><br><br>

        <input type="checkbox" id="emprunte" name="emprunte">
        <label for="emprunte">Emprunté (ne nous appartient pas)</label><br>
        <input type="text" id="emprunte-a" name="emprunte-a" placeholder="Nom de la personne" style="display: none;"><br><br>

        <button type="submit">Ajouter le jeu</button>
      </form>
    </div>
  </div>

  <button class="btn-home" onclick="location.href='index.html'">🏠 Home</button>

  <script type="module">
    console.log("Script jeux.html chargé.");

    import { supabase } from './supabase-config.js';

    let jeux = [];
    let joueurs = []; // Ajout de la liste des joueurs
    let partiesStats = new Map(); // Map pour stocker les stats: NomJeu -> { parties: Number, scores: Map<String, Number> }
    let proprietaires = [];
    const photosBucket = 'jeu-photos';
    
    // Ajout de la Map de conversion ID -> Nom
    let joueurIdToNom = new Map();

    const modal = document.getElementById('modal-ajout');
    const btnAdd = document.querySelector('.btn-add');
    const btnFermer = document.getElementById('btn-fermer');
    const formAjout = document.getElementById('form-ajout');
    const listeJeux = document.getElementById('liste-jeux');
    const inputRecherche = document.getElementById('recherche-jeux');
    const alphaFilterContainer = document.getElementById('alpha-filter-container');

    const jeuIdInput = document.getElementById('jeu-id');
    const nomJeuInput = document.getElementById('nom-jeu');
    const proprietaireJeuSelect = document.getElementById('proprietaire-jeu');
    const photosJeuInput = document.getElementById('photos-jeu');
    const minJoueursInput = document.getElementById('min-joueurs');
    const maxJoueursInput = document.getElementById('max-joueurs');
    const preteCheckbox = document.getElementById('prete');
    const preteAInput = document.getElementById('prete-a');
    const emprunteCheckbox = document.getElementById('emprunte');
    const emprunteAInput = document.getElementById('emprunte-a');
    const photosPreviewContainer = document.getElementById('photos-preview-container');
    const photosPreviewDiv = document.getElementById('photos-preview');

    let currentAlphaFilter = '';
    let selectedGroupId = null;

    // Redirection si aucun groupe n'est sélectionné
    selectedGroupId = localStorage.getItem('selected_group_id');
    if (!selectedGroupId) {
        location.href = 'login.html';
    } else {
        const selectedGroupAlias = localStorage.getItem('selected_group_alias');
        document.getElementById('current-group-alias').textContent = `Groupe : ${selectedGroupAlias}`;
    }

    // --- Fonctions de gestion des joueurs (NÉCESSAIRE pour la conversion ID->Nom) ---
    async function chargerJoueurs() {
        try {
            const { data, error } = await supabase
                .from('joueurs')
                .select('id, nom')
                .eq('groupe_id', selectedGroupId); 
            if (error) throw error;
            return data;
        } catch (error) {
            console.error("Erreur lors du chargement des joueurs:", error);
            return [];
        }
    }


    // --- Fonctions de gestion des propriétaires (Aucun changement) ---
    async function chargerProprietaires() {
        try {
            const { data, error } = await supabase
                .from('proprietaires')
                .select('*')
                .eq('groupe_id', selectedGroupId)
                .order('nom', { ascending: true });
            if (error) throw error;
            proprietaires = data;
            mettreAJourSelectProprietaires();
        } catch (error) {
            console.error("Erreur lors du chargement des propriétaires:", error);
        }
    }
    // ... (mettreAJourSelectProprietaires, ajouterNouveauProprietaire, proprietaireJeuSelect.addEventListener restent inchangés) ...
    function mettreAJourSelectProprietaires() {
        const options = Array.from(proprietaireJeuSelect.options).filter(opt => opt.value === "" || opt.value === "ajouter-proprietaire");
        proprietaireJeuSelect.innerHTML = '';
        options.forEach(opt => proprietaireJeuSelect.appendChild(opt));

        proprietaires.forEach(p => {
            const option = document.createElement('option');
            option.value = p.id;
            option.textContent = p.nom;
            proprietaireJeuSelect.insertBefore(option, proprietaireJeuSelect.options[proprietaireJeuSelect.options.length - 1]);
        });
    }

    async function ajouterNouveauProprietaire() {
        const nom = prompt("Entrez le nom du nouveau propriétaire :");
        if (nom && nom.trim() !== '') {
            try {
                const { data, error } = await supabase.from('proprietaires')
                    .insert({ nom: nom.trim(), groupe_id: selectedGroupId })
                    .select();
                if (error) {
                    if (error.code === '23505') {
                        alert("Ce propriétaire existe déjà.");
                    } else {
                        throw error;
                    }
                } else {
                    proprietaires.push(data[0]);
                    proprietaires.sort((a, b) => a.nom.localeCompare(b.nom));
                    mettreAJourSelectProprietaires();
                    proprietaireJeuSelect.value = data[0].id;
                }
            } catch (error) {
                console.error("Erreur lors de l'ajout du propriétaire:", error);
                alert("Erreur lors de l'ajout du propriétaire: " + error.message);
            }
        }
    }

    proprietaireJeuSelect.addEventListener('change', (e) => {
        if (e.target.value === 'ajouter-proprietaire') {
            ajouterNouveauProprietaire();
        }
    });

    // --- Fonctions de gestion des photos avec Supabase Storage (Aucun changement) ---
    async function uploaderPhotos(photosFiles) {
        const photosUrls = [];
        for (const file of photosFiles) {
            const fileExt = file.name.split('.').pop();
            const fileName = `${selectedGroupId}/${Date.now()}-${Math.random().toString(36).substring(2)}.${fileExt}`;
            const { data, error } = await supabase.storage.from(photosBucket).upload(fileName, file);

            if (error) {
                console.error("Erreur lors de l'upload de l'image:", error);
                alert(`Erreur lors de l'upload de l'image: ${error.message}`);
                continue;
            }

            const { data: urlData, error: publicUrlError } = supabase.storage.from(photosBucket).getPublicUrl(data.path);
            if (publicUrlError) {
                console.error("Erreur lors de la récupération de l'URL publique:", publicUrlError);
                alert(`Erreur lors de la récupération de l'URL publique: ${publicUrlError.message}`);
                continue;
            }

            photosUrls.push(urlData.publicUrl);
        }
        return photosUrls;
    }

    async function supprimerPhotos(photosUrls) {
        if (!photosUrls || !Array.isArray(photosUrls) || photosUrls.length === 0) {
            console.log("Aucune photo à supprimer ou l'argument n'est pas un tableau.");
            return;
        }
        
        const filePaths = photosUrls.map(url => {
            const pathSegments = url.split('/');
            return pathSegments[pathSegments.length - 2] + '/' + pathSegments[pathSegments.length - 1];
        });

        const { data, error } = await supabase.storage.from(photosBucket).remove(filePaths);
        if (error) {
            console.error("Erreur lors de la suppression des images du storage:", error);
        }
    }

    // --- Fonction de chargement des statistiques de parties (MAJEURE MODIFICATION) ---
    async function chargerStatistiquesParties() {
        try {
            // 1. Charger toutes les lignes de jointure pour ce groupe (partie_id, joueur_id, est_gagnant)
            const { data: jointureData, error: jointureError } = await supabase
                .from('parties_joueurs')
                .select('partie_id, joueur_id, est_gagnant, parties(nom_jeu)')
                .eq('parties.groupe_id', selectedGroupId); // Filtrage côté BDD via la relation

            if (jointureError) throw jointureError;

            // 2. Initialiser la map de statistiques
            const stats = new Map(); // Clé: nom_jeu, Valeur: { parties: Number, scores: Map<String, Number> }

            // 3. Compter les parties et les victoires par jeu
            const partiesComptees = new Set();

            jointureData.forEach(line => {
                const nomJeu = line.parties.nom_jeu;
                const nomJoueur = joueurIdToNom.get(line.joueur_id); 
                const partieId = line.partie_id;

                if (!stats.has(nomJeu)) {
                    stats.set(nomJeu, { parties: 0, scores: new Map() });
                }

                const jeuStats = stats.get(nomJeu);

                // Compter le nombre de parties jouées (une fois par partie)
                if (!partiesComptees.has(`${nomJeu}-${partieId}`)) {
                    jeuStats.parties++;
                    partiesComptees.add(`${nomJeu}-${partieId}`);
                }

                // Compter les victoires
                if (line.est_gagnant && nomJoueur) {
                    const currentScore = jeuStats.scores.get(nomJoueur) || 0;
                    jeuStats.scores.set(nomJoueur, currentScore + 1);
                }
            });

            partiesStats = stats;
            return stats;

        } catch (error) {
            console.error("Erreur lors du chargement des statistiques de parties:", error);
            return new Map();
        }
    }

    // --- Fonctions de gestion des jeux (Peu de changement) ---
    async function chargerJeux() {
        try {
            const { data, error } = await supabase
                .from('jeux')
                .select('*, proprietaires(nom)')
                .eq('groupe_id', selectedGroupId)
                .order('nom', { ascending: true }); // Triage par défaut dans le chargement
            if (error) throw error;
            return data;
        } catch (error) {
            console.error("Erreur lors du chargement des jeux:", error);
            alert(`Une erreur est survenue lors du chargement des jeux: ${error.message}`);
            return [];
        }
    }

    // ... (ajouterJeu, modifierJeu, supprimerJeu restent inchangés) ...
    async function ajouterJeu(jeuData) {
        try {
            const { data, error } = await supabase
                .from('jeux')
                .insert({ ...jeuData, groupe_id: selectedGroupId })
                .select();
            if (error) throw error;
            return { success: true, data: data[0] };
        } catch (error) {
            console.error("Erreur lors de l'ajout du jeu:", error);
            alert(`Une erreur est survenue lors de l'ajout du jeu: ${error.message}`);
            return { success: false, error };
        }
    }

    async function modifierJeu(id, jeuData) {
        try {
            const { data, error } = await supabase
                .from('jeux')
                .update(jeuData)
                .eq('id', id)
                .select();
            if (error) throw error;
            return { success: true, data: data[0] };
        } catch (error) {
            console.error("Erreur lors de la modification du jeu:", error);
            alert(`Une erreur est survenue lors de la modification du jeu: ${error.message}`);
            return { success: false, error };
        }
    }

    async function supprimerJeu(id) {
        try {
            const jeuASupprimer = jeux.find(j => j.id === id);
            if (jeuASupprimer && Array.isArray(jeuASupprimer.photos) && jeuASupprimer.photos.length > 0) {
                await supprimerPhotos(jeuASupprimer.photos);
            }
            const { error } = await supabase
                .from('jeux')
                .delete()
                .eq('id', id);
            if (error) throw error;
            return { success: true };
        } catch (error) {
            console.error("Erreur lors de la suppression du jeu:", error);
            alert(`Une erreur est survenue lors de la suppression du jeu: ${error.message}`);
            return { success: false, error };
        }
    }

    // --- Fonctions de contrôle et d'affichage (MODIFICATION) ---
    async function chargerEtAfficherJeux() {
        console.log("Chargement et affichage des jeux et stats depuis Supabase...");
        
        // 1. Charger joueurs et créer la map (pour la conversion ID -> Nom dans les stats)
        joueurs = await chargerJoueurs();
        joueurIdToNom.clear();
        joueurs.forEach(j => joueurIdToNom.set(j.id, j.nom));

        // 2. Charger les jeux et les statistiques (dépend de la map)
        [jeux] = await Promise.all([
            chargerJeux(),
            chargerStatistiquesParties() // Charge et remplit partiesStats
        ]);
        
        afficherListeJeux();
    }


    function afficherListeJeux() {
        console.log("Affichage de la liste des jeux...");
        listeJeux.innerHTML = '';
        const filterText = inputRecherche.value.toLowerCase();
        const jeuxTries = [...jeux].sort((a, b) => a.nom.localeCompare(b.nom));

        // ... (Logique de filtres alpha/texte inchangée) ...
        if (jeuxTries.length === 0 && !filterText && !currentAlphaFilter) {
            listeJeux.innerHTML = '<p style="text-align: center; color: #666; margin-top: 20px;">Aucun jeu n\'est enregistré. Ajoutez-en un !</p>';
            return;
        }
        let jeuxFiltres = jeuxTries.filter(jeu => {
            if (filterText && !jeu.nom.toLowerCase().includes(filterText)) {
                return false;
            }
            if (currentAlphaFilter && !jeu.nom.toLowerCase().startsWith(currentAlphaFilter.toLowerCase())) {
                return false;
            }
            return true;
        });
        if (jeuxFiltres.length === 0) {
            listeJeux.innerHTML = '<p style="text-align: center; color: #666; margin-top: 20px;">Aucun jeu ne correspond à vos critères de recherche.</p>';
            return;
        }
        
        // --- MISE À JOUR DE L'AFFICHAGE DES STATISTIQUES ---
        jeuxFiltres.forEach((jeu) => {
            const card = document.createElement('div');
            card.className = 'jeu-card';
            
            // ... (Affichage de l'image, tags propriétaire/prêté/emprunté, infos joueurs) ...
            const img = document.createElement('img');
            img.src = (jeu.photos && jeu.photos.length > 0)
                ? jeu.photos[0]
                : 'https://via.placeholder.com/280x160?text=Pas+de+photo';
            img.alt = `Image de ${jeu.nom}`;
            card.appendChild(img);
            if (jeu.proprietaires && jeu.proprietaires.nom) {
                const tagProprietaire = document.createElement('span');
                tagProprietaire.className = 'tag-proprietaire';
                tagProprietaire.textContent = `Propriétaire : ${jeu.proprietaires.nom}`;
                card.appendChild(tagProprietaire);
            }
            if (jeu.emprunte) {
                const tagEmprunte = document.createElement('span');
                tagEmprunte.className = 'tag-emprunte';
                tagEmprunte.textContent = `EMPRUNTÉ${jeu.emprunte_a ? ` À ${jeu.emprunte_a.toUpperCase()}` : ''}`;
                card.appendChild(tagEmprunte);
            }
            if (jeu.prete) {
                const overlayPrete = document.createElement('div');
                overlayPrete.className = 'overlay-prete';
                const overlayText = document.createElement('span');
                overlayText.className = 'text';
                overlayText.textContent = `PRÊTÉ${jeu.prete_a ? ` À ${jeu.prete_a.toUpperCase()}` : ''}`;
                overlayPrete.appendChild(overlayText);
                card.appendChild(overlayPrete);
            }
            const contentDiv = document.createElement('div');
            contentDiv.className = 'jeu-content';
            const titre = document.createElement('h3');
            titre.textContent = jeu.nom;
            contentDiv.appendChild(titre);
            const infosComplementaires = document.createElement('div');
            infosComplementaires.className = 'infos-complementaires';
            if (jeu.min_joueurs && jeu.max_joueurs && !isNaN(jeu.min_joueurs) && !isNaN(jeu.max_joueurs)) {
                const joueursIcons = document.createElement('p');
                let joueursTexte = '';
                const minEmojis = '&#128100;'.repeat(jeu.min_joueurs);
                const maxEmojis = '&#128100;'.repeat(jeu.max_joueurs);
                if (jeu.min_joueurs === jeu.max_joueurs) {
                    joueursTexte = `${minEmojis}`;
                } else {
                    joueursTexte = `${minEmojis} - ${maxEmojis}`;
                }
                joueursIcons.innerHTML = `<span>${joueursTexte} (${jeu.min_joueurs}-${jeu.max_joueurs})</span> <span class="info-label">Joueurs</span>`;
                infosComplementaires.appendChild(joueursIcons);
            } else if (jeu.min_joueurs && !isNaN(jeu.min_joueurs)) {
                 const joueursIcons = document.createElement('p');
                 joueursIcons.innerHTML = `<span>${'&#128100;'.repeat(jeu.min_joueurs)}+</span> <span class="info-label">Joueurs</span>`;
                 infosComplementaires.appendChild(joueursIcons);
            } else if (jeu.max_joueurs && !isNaN(jeu.max_joueurs)) {
                 const joueursIcons = document.createElement('p');
                 joueursIcons.innerHTML = `<span>Jusqu'à ${'&#128100;'.repeat(jeu.max_joueurs)}</span> <span class="info-label">Joueurs</span>`;
                 infosComplementaires.appendChild(joueursIcons);
            }
            contentDiv.appendChild(infosComplementaires);
            
            // Récupération des stats du jeu
            const jeuStats = partiesStats.get(jeu.nom) || { parties: 0, scores: new Map() };
            const nbParties = jeuStats.parties;
            const scores = jeuStats.scores; // Map<String, Number>

            let meilleur = null;
            let max = 0;
            
            // Trouver le meilleur joueur
            for (const [joueur, score] of scores.entries()) {
                if (score > max) {
                    max = score;
                    meilleur = joueur;
                }
            }

            const stats = document.createElement('div');
            stats.className = 'stats';
            stats.innerHTML = `
                Parties jouées : <strong>${nbParties}</strong><br>
                Meilleur joueur : <strong>${meilleur ? `${meilleur} (${max} victoire${max > 1 ? 's' : ''})` : 'Aucun'}</strong>
            `;
            contentDiv.appendChild(stats);
            
            // ... (Boutons Modifier/Supprimer/Parties) ...
            const btns = document.createElement('div');
            btns.className = 'btns-card';
            const btnModifier = document.createElement('button');
            btnModifier.className = 'btn-card btn-modifier';
            btnModifier.textContent = '✏️ Modifier';
            btnModifier.addEventListener('click', (event) => {
                event.stopPropagation();
                ouvrirModaleModifier(jeu.id);
            });
            btns.appendChild(btnModifier);
            const btnSupprimer = document.createElement('button');
            btnSupprimer.className = 'btn-card btn-supprimer';
            btnSupprimer.textContent = '🗑️ Supprimer';
            btnSupprimer.addEventListener('click', async (event) => {
                event.stopPropagation();
                if (confirm(`Supprimer le jeu "${jeu.nom}" ?`)) {
                    const result = await supprimerJeu(jeu.id);
                    if (result.success) {
                        alert(`Jeu "${jeu.nom}" supprimé avec succès !`);
                        await chargerEtAfficherJeux();
                    } else {
                        console.error("Erreur lors de la suppression:", result.error);
                    }
                }
            });
            btns.appendChild(btnSupprimer);
            const btnParties = document.createElement('button');
            btnParties.className = 'btn-card btn-parties';
            btnParties.textContent = '▶️ Voir parties';
            btnParties.addEventListener('click', (event) => {
                event.stopPropagation();
                window.location.href = `parties.html?jeu=${encodeURIComponent(jeu.nom)}`;
            });
            btns.appendChild(btnParties);
            contentDiv.appendChild(btns);
            card.appendChild(contentDiv);
            listeJeux.appendChild(card);
        });
    }

    // ... (ouvrirModaleModifier et autres listeners restent inchangés) ...
    function ouvrirModaleModifier(id) {
        console.log("Ouverture modale pour modification, ID:", id);
        const jeu = jeux.find(j => j.id === id);
        if (!jeu) {
            console.error("Jeu non trouvé avec l'ID:", id);
            alert("Erreur: Impossible de charger les données du jeu.");
            return;
        }
        jeuIdInput.value = jeu.id;
        nomJeuInput.value = jeu.nom;
        proprietaireJeuSelect.value = jeu.proprietaire_id || '';
        minJoueursInput.value = jeu.min_joueurs !== undefined ? jeu.min_joueurs : '';
        maxJoueursInput.value = jeu.max_joueurs !== undefined ? jeu.max_joueurs : '';
        preteCheckbox.checked = jeu.prete === true;
        preteAInput.value = jeu.prete_a || '';
        preteAInput.style.display = preteCheckbox.checked ? 'block' : 'none';
        emprunteCheckbox.checked = jeu.emprunte === true;
        emprunteAInput.value = jeu.emprunte_a || '';
        emprunteAInput.style.display = emprunteCheckbox.checked ? 'block' : 'none';

        photosPreviewDiv.innerHTML = '';
        const photos = Array.isArray(jeu.photos) ? jeu.photos : [];
        if (photos.length > 0) {
            photosPreviewContainer.style.display = 'block';
            photos.forEach(url => {
                const img = document.createElement('img');
                img.src = url;
                img.style.width = '100px';
                img.style.height = '60px';
                img.style.objectFit = 'cover';
                img.style.border = '1px solid #ccc';
                photosPreviewDiv.appendChild(img);
            });
        } else {
            photosPreviewContainer.style.display = 'none';
        }

        formAjout.querySelector('button[type="submit"]').textContent = 'Modifier le jeu';
        modal.style.display = 'flex';
    }


    inputRecherche.addEventListener('input', () => {
        currentAlphaFilter = '';
        document.querySelectorAll('.alpha-filter-btn').forEach(b => b.classList.remove('active'));
        const allBtn = document.querySelector('.alpha-filter-btn[data-filter=""]');
        if (allBtn) allBtn.classList.add('active');
        afficherListeJeux();
    });

    document.addEventListener('DOMContentLoaded', async () => {
        generateAlphaFilters();
        await chargerProprietaires();
        await chargerEtAfficherJeux();
    });

    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState === 'visible') {
        await chargerEtAfficherJeux();
      }
    });

    // ... (Service Worker script reste inchangé) ...
  </script>

  <script>
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('/service-worker.js')
                .then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                }, err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
        });
    }
  </script>
</body>
</html>